import React, { useState, useEffect, useRef } from 'react';

// --- æ¸¸æˆæ ¸å¿ƒé€»è¾‘ä¸å¸¸é‡ ---

const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
const VALUES = [
  '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'
];

// æƒé‡å€¼ï¼Œç”¨äºæ¯”è¾ƒå¤§å°
const VALUE_MAP = {
  '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
  'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15,
  'black_joker': 20, 'red_joker': 21
};

const TYPES = {
  SINGLE: 'SINGLE',
  PAIR: 'PAIR',
  TRIPLE: 'TRIPLE',
  TRIPLE_ONE: 'TRIPLE_ONE',
  TRIPLE_TWO: 'TRIPLE_TWO',
  BOMB: 'BOMB',
  ROCKET: 'ROCKET',
  STRAIGHT: 'STRAIGHT',
  STRAIGHT_PAIR: 'STRAIGHT_PAIR', 
  PLANE: 'PLANE', 
  INVALID: 'INVALID'
};

const DIFFICULTIES = {
  EASY: { label: 'ç®€å•', color: 'bg-green-500' },
  NORMAL: { label: 'æ™®é€š', color: 'bg-blue-500' },
  HARD: { label: 'å›°éš¾', color: 'bg-red-500' }
};

// ç”Ÿæˆä¸€å‰¯ç‰Œ
const createDeck = () => {
  let deck = [];
  let id = 0;
  // æ™®é€šç‰Œ
  for (let v of VALUES) {
    for (let s of SUITS) {
      deck.push({
        id: id++,
        value: v,
        suit: s,
        rank: VALUE_MAP[v],
        display: v
      });
    }
  }
  // å¤§å°ç‹
  deck.push({ id: id++, value: 'black_joker', suit: '', rank: 20, display: 'Joker', isJoker: true, color: 'black' });
  deck.push({ id: id++, value: 'red_joker', suit: '', rank: 21, display: 'Joker', isJoker: true, color: 'red' });
  return deck;
};

// ç‰Œå‹åˆ†æä¸æ¯”è¾ƒé€»è¾‘
const GameLogic = {
  sortCards: (cards) => {
    return [...cards].sort((a, b) => b.rank - a.rank); // é™åº: å¤§ -> å°
  },

  // åˆ†æç‰Œå‹
  analyzeHand: (cards) => {
    if (cards.length === 0) return { type: TYPES.INVALID };
    
    const sorted = GameLogic.sortCards(cards);
    const len = sorted.length;
    const ranks = sorted.map(c => c.rank);
    
    // ç»Ÿè®¡æ¯å¼ ç‰Œçš„æ•°é‡
    const counts = {};
    ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
    const uniqueRanks = Object.keys(counts).map(Number).sort((a, b) => b - a); // é™åº

    // 1. ç‹ç‚¸
    if (len === 2 && ranks[0] === 21 && ranks[1] === 20) return { type: TYPES.ROCKET, rank: 100 };

    // 2. ç‚¸å¼¹
    if (len === 4 && uniqueRanks.length === 1) return { type: TYPES.BOMB, rank: ranks[0] };

    // 3. å•å¼ 
    if (len === 1) return { type: TYPES.SINGLE, rank: ranks[0] };

    // 4. å¯¹å­
    if (len === 2 && uniqueRanks.length === 1) return { type: TYPES.PAIR, rank: ranks[0] };

    // 5. ä¸‰å¼ 
    if (len === 3 && uniqueRanks.length === 1) return { type: TYPES.TRIPLE, rank: ranks[0] };

    // 6. ä¸‰å¸¦ä¸€
    if (len === 4) {
      const tripleRank = uniqueRanks.find(r => counts[r] === 3);
      if (tripleRank) return { type: TYPES.TRIPLE_ONE, rank: tripleRank };
    }

    // 7. ä¸‰å¸¦äºŒ (ä¸€å¯¹)
    if (len === 5) {
      const tripleRank = uniqueRanks.find(r => counts[r] === 3);
      const pairRank = uniqueRanks.find(r => counts[r] === 2);
      if (tripleRank && pairRank) return { type: TYPES.TRIPLE_TWO, rank: tripleRank };
    }

    // 8. é¡ºå­ (5å¼ åŠä»¥ä¸Š, æœ€å¤§æ˜¯A, ä¸èƒ½æœ‰2å’Œç‹)
    if (len >= 5 && uniqueRanks.length === len) {
      const max = ranks[0];
      const min = ranks[len - 1];
      if (max < 15 && (max - min) === (len - 1)) {
        return { type: TYPES.STRAIGHT, rank: max, len: len };
      }
    }

    // 9. è¿å¯¹ (3å¯¹åŠä»¥ä¸Š)
    if (len >= 6 && len % 2 === 0 && uniqueRanks.length === len / 2) {
       const max = uniqueRanks[0];
       const min = uniqueRanks[uniqueRanks.length - 1];
       if (max < 15 && (max - min) === (uniqueRanks.length - 1) && Object.values(counts).every(c => c === 2)) {
         return { type: TYPES.STRAIGHT_PAIR, rank: max, len: len };
       }
    }

    return { type: TYPES.INVALID };
  },

  // åˆ¤æ–­èƒ½å¦ç®¡ä¸Š
  canBeat: (playedCards, targetHand) => {
    if (!targetHand) {
      const type = GameLogic.analyzeHand(playedCards);
      return type.type !== TYPES.INVALID;
    }

    const currentHand = GameLogic.analyzeHand(playedCards);
    if (currentHand.type === TYPES.INVALID) return false;

    // ç‹ç‚¸æ— æ•Œ
    if (currentHand.type === TYPES.ROCKET) return true;
    if (targetHand.type === TYPES.ROCKET) return false;

    // ç‚¸å¼¹ç®¡æ™®é€šç‰Œ
    if (currentHand.type === TYPES.BOMB && targetHand.type !== TYPES.BOMB) return true;

    // åŒç±»å‹æ¯”è¾ƒ
    if (currentHand.type === targetHand.type) {
      if (currentHand.type === TYPES.STRAIGHT || currentHand.type === TYPES.STRAIGHT_PAIR) {
        if (currentHand.len !== targetHand.len) return false;
      }
      return currentHand.rank > targetHand.rank;
    }

    return false;
  },

  // --- AI æ ¸å¿ƒè¾…åŠ©å‡½æ•° ---

  // ä»æ‰‹ç‰Œä¸­æå–æŒ‡å®šæ•°é‡çš„ç‰Œ (helper)
  getCardsByRank: (hand, rank, count) => {
      const target = hand.filter(c => c.rank === rank);
      return target.length >= count ? target.slice(0, count) : [];
  },

  // æŸ¥æ‰¾èƒ½å¤§è¿‡ targetRank çš„ç›¸åŒç‰Œå‹
  findCardsByType: (hand, type, minRank, length = 0) => {
      const counts = {};
      hand.forEach(c => counts[c.rank] = (counts[c.rank] || 0) + 1);
      const ranks = Object.keys(counts).map(Number).sort((a, b) => a - b); // å‡åºï¼Œæ–¹ä¾¿æ‰¾æœ€å°çš„

      if (type === TYPES.SINGLE) {
          const valid = ranks.find(r => r > minRank);
          return valid ? GameLogic.getCardsByRank(hand, valid, 1) : null;
      }
      if (type === TYPES.PAIR) {
          const valid = ranks.find(r => r > minRank && counts[r] >= 2);
          return valid ? GameLogic.getCardsByRank(hand, valid, 2) : null;
      }
      if (type === TYPES.TRIPLE) {
          const valid = ranks.find(r => r > minRank && counts[r] >= 3);
          return valid ? GameLogic.getCardsByRank(hand, valid, 3) : null;
      }
      if (type === TYPES.BOMB) {
          const valid = ranks.find(r => r > minRank && counts[r] === 4);
          return valid ? GameLogic.getCardsByRank(hand, valid, 4) : null;
      }
      if (type === TYPES.TRIPLE_ONE) {
          // æ‰¾ä¸€ä¸ªä¸‰å¼ 
          const tripleRank = ranks.find(r => r > minRank && counts[r] >= 3);
          if (tripleRank) {
              const tripleCards = GameLogic.getCardsByRank(hand, tripleRank, 3);
              // æ‰¾ä¸€ä¸ªå•å¼  (ä¸åŒ…å«åˆšæ‰çš„ä¸‰å¼ )
              // ç®€å•ç­–ç•¥ï¼šæ‰¾æœ€å°çš„å•å¼ ï¼Œå°½é‡ä¿ç•™ç‚¸å¼¹
              const singleRank = ranks.find(r => r !== tripleRank); 
              if (singleRank) {
                   const singleCard = GameLogic.getCardsByRank(hand, singleRank, 1);
                   return [...tripleCards, ...singleCard];
              }
          }
          return null;
      }
      if (type === TYPES.TRIPLE_TWO) {
          const tripleRank = ranks.find(r => r > minRank && counts[r] >= 3);
          if (tripleRank) {
              const tripleCards = GameLogic.getCardsByRank(hand, tripleRank, 3);
              // æ‰¾ä¸€ä¸ªå¯¹å­
              const pairRank = ranks.find(r => r !== tripleRank && counts[r] >= 2);
              if (pairRank) {
                  const pairCards = GameLogic.getCardsByRank(hand, pairRank, 2);
                  return [...tripleCards, ...pairCards];
              }
          }
          return null;
      }
      if (type === TYPES.STRAIGHT) {
          // å¯»æ‰¾é•¿åº¦ä¸º lengthï¼Œä¸”æœ€å°ç‰Œ > minRank çš„é¡ºå­
          // è¿‡æ»¤é‡å¤rankï¼Œåªç•™ä¸€å¼ ç”¨äºæ£€æŸ¥è¿ç»­æ€§
          const uniqueCards = [];
          ranks.forEach(r => {
             if (r < 15) uniqueCards.push(hand.find(c => c.rank === r)); // æ’é™¤2å’Œç‹
          });
          uniqueCards.sort((a,b) => a.rank - b.rank);
          
          for (let i = 0; i <= uniqueCards.length - length; i++) {
              if (uniqueCards[i].rank > minRank) {
                  // æ£€æŸ¥è¿ç»­æ€§
                  let isStraight = true;
                  for (let j = 1; j < length; j++) {
                      if (uniqueCards[i+j].rank !== uniqueCards[i].rank + j) {
                          isStraight = false;
                          break;
                      }
                  }
                  if (isStraight) {
                      return uniqueCards.slice(i, i + length);
                  }
              }
          }
          return null;
      }
      // ç®€å•èµ·è§ï¼Œè¿å¯¹æš‚ç•¥ï¼Œå› ä¸ºé€»è¾‘ç±»ä¼¼é¡ºå­ä½†æ›´å¤æ‚
      return null;
  },

  // AI é€‰ç‰Œç­–ç•¥
  findBestMove: (hand, targetHand, difficulty = 'NORMAL') => {
    const sortedHand = GameLogic.sortCards(hand);
    
    // é”™è¯¯ç‡é€»è¾‘
    if (difficulty === 'EASY' && targetHand && Math.random() < 0.2) return null;

    // --- ä¸»åŠ¨å‡ºç‰Œé€»è¾‘ (LEAD) ---
    if (!targetHand) {
        // 1. å¦‚æœä¸€æ‰‹èƒ½å‡ºå®Œï¼Œç›´æ¥å‡º
        const fullHandType = GameLogic.analyzeHand(sortedHand);
        if (fullHandType.type !== TYPES.INVALID) return sortedHand;

        // 2. å°è¯•å‡ºä¸‰å¸¦ä¸€æˆ–ä¸‰å¸¦äºŒ (ä¼˜å…ˆå‡ºå°çš„)
        // ç»Ÿè®¡
        const counts = {};
        sortedHand.forEach(c => counts[c.rank] = (counts[c.rank] || 0) + 1);
        const ranks = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // æ‰¾ä¸‰å¼ 
        const tripleRank = ranks.find(r => counts[r] === 3);
        if (tripleRank) {
             const tripleCards = sortedHand.filter(c => c.rank === tripleRank);
             // å°è¯•å¸¦å•å¼ 
             const singleRank = ranks.find(r => r !== tripleRank && counts[r] === 1);
             if (singleRank) {
                 return [...tripleCards, sortedHand.find(c => c.rank === singleRank)];
             }
             // å°è¯•å¸¦å¯¹å­
             const pairRank = ranks.find(r => r !== tripleRank && counts[r] === 2);
             if (pairRank) {
                 return [...tripleCards, ...sortedHand.filter(c => c.rank === pairRank)];
             }
             // å•¥éƒ½æ²¡å¸¦ï¼Œç›´æ¥å‡ºä¸‰å¼  (è™½ç„¶è§„åˆ™é€šå¸¸ä¸å…è®¸åªå‡ºä¸‰å¼ ï¼Œä½†éƒ¨åˆ†è§„åˆ™å…è®¸ï¼Œè¿™é‡Œä½œä¸ºä¿åº•)
             // æˆ–è€…å¦‚æœæ‰¾ä¸åˆ°å¸¦ç‰Œï¼Œå°±ä¸å‡ºä¸‰å¼ ï¼Œå¾€ä¸‹èµ°å‡ºå¯¹å­
        }

        // 3. å°è¯•å‡ºé¡ºå­ (ç®€å•æ£€æµ‹ï¼šæ˜¯å¦æœ‰5å¼ è¿ç»­)
        // (ç•¥å¾®å¤æ‚ï¼Œä½œä¸ºä¼˜åŒ–ç‚¹ï¼Œæš‚ä¼˜å…ˆå‡ºå¯¹å­å’Œå•å¼ )

        // 4. å°è¯•å‡ºå¯¹å­ (æœ€å°çš„)
        const pairRank = ranks.find(r => counts[r] === 2);
        if (pairRank) {
            return sortedHand.filter(c => c.rank === pairRank);
        }

        // 5. å®åœ¨æ²¡æ‹›ï¼Œå‡ºæœ€å°å•å¼ 
        // å›°éš¾æ¨¡å¼ï¼šå°½é‡ä¿ç•™2å’Œç‹
        if (difficulty === 'HARD') {
            for (let i = sortedHand.length - 1; i >= 0; i--) {
                if (sortedHand[i].rank < 15) return [sortedHand[i]];
            }
        }
        return [sortedHand[sortedHand.length - 1]];
    }

    // --- è·Ÿç‰Œé€»è¾‘ (FOLLOW) ---
    
    // 1. å¯¹æ–¹æ˜¯ç‹ç‚¸ -> æŠ•é™
    if (targetHand.type === TYPES.ROCKET) return null;

    // 2. å°è¯•åŒç±»å‹å‹åˆ¶
    let bestMove = null;
    
    // ä¼˜å…ˆåŒ¹é…ç›¸åŒç‰Œå‹
    if (targetHand.type === TYPES.SINGLE) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.SINGLE, targetHand.rank);
    else if (targetHand.type === TYPES.PAIR) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.PAIR, targetHand.rank);
    else if (targetHand.type === TYPES.TRIPLE) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.TRIPLE, targetHand.rank);
    else if (targetHand.type === TYPES.TRIPLE_ONE) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.TRIPLE_ONE, targetHand.rank);
    else if (targetHand.type === TYPES.TRIPLE_TWO) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.TRIPLE_TWO, targetHand.rank);
    else if (targetHand.type === TYPES.STRAIGHT) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.STRAIGHT, targetHand.rank, targetHand.len);
    else if (targetHand.type === TYPES.BOMB) bestMove = GameLogic.findCardsByType(sortedHand, TYPES.BOMB, targetHand.rank);

    if (bestMove) return bestMove;

    // 3. ç‚¸å¼¹å‹åˆ¶ (å¦‚æœå¯¹æ–¹ä¸æ˜¯ç‚¸å¼¹ï¼Œæˆ–è€…å¯¹æ–¹æ˜¯ç‚¸å¼¹ä½†æˆ‘æ›´å¤§)
    if (targetHand.type !== TYPES.BOMB && targetHand.type !== TYPES.ROCKET) {
        return GameLogic.findCardsByType(sortedHand, TYPES.BOMB, 0); // æ‰¾ä»»æ„ç‚¸å¼¹
    } 

    // 4. ç‹ç‚¸å‹åˆ¶
    const jokers = sortedHand.filter(c => c.rank >= 20);
    if (jokers.length === 2) return jokers;

    return null; // è¦ä¸èµ·
  }
};


// --- UI ç»„ä»¶ ---

const Card = ({ card, selected, onClick, small = false, hidden = false, isLord = false }) => {
  if (hidden) {
    return (
      <div 
        className={`
          ${small ? 'w-10 h-14' : 'w-20 h-28 md:w-24 md:h-36'} 
          bg-blue-600 border-2 border-white rounded-lg shadow-md flex items-center justify-center
          bg-opacity-90 bg-pattern transform transition-all duration-200
        `}
      >
        <div className="w-full h-full border border-blue-400 rounded opacity-50 m-1 flex items-center justify-center">
            <div className="text-white opacity-20 text-2xl font-bold">CARD</div>
        </div>
      </div>
    );
  }

  const isRed = card.suit === 'â™¥' || card.suit === 'â™¦' || card.color === 'red';
  
  return (
    <div
      onClick={() => onClick && onClick(card)}
      className={`
        relative flex flex-col items-center justify-between p-1
        ${small ? 'w-10 h-14 text-sm' : 'w-20 h-28 md:w-24 md:h-36 text-xl'} 
        bg-white rounded-lg shadow-md cursor-pointer select-none transition-all duration-200
        ${selected ? '-translate-y-6 border-yellow-400 ring-4 ring-yellow-400 z-10' : 'hover:-translate-y-2'}
        ${isRed ? 'text-red-600' : 'text-black'}
      `}
      style={{ border: '1px solid #ccc' }}
    >
      <div className="self-start font-bold leading-none">
        <div>{card.display}</div>
        <div className="text-xs scale-75 origin-top-left">{card.suit}</div>
      </div>
      
      {isLord && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl opacity-20 pointer-events-none">
            ğŸ¤ 
        </div>
      )}

      <div className={`${small ? 'text-xl' : 'text-4xl'}`}>{card.suit}</div>
      {!small && (
         <div className="self-end font-bold leading-none rotate-180">
            <div>{card.display}</div>
            <div className="text-xs">{card.suit}</div>
        </div>
      )}
    </div>
  );
};

// ç©å®¶æ‰‹ç‰ŒåŒºåŸŸ
const Hand = ({ cards, isUser, onSelectCard, selectedCards = [], isLandlord }) => {
  return (
    <div className="flex justify-center items-end -space-x-12 md:-space-x-14 min-h-[140px] px-4">
      {cards.map((card, idx) => (
        <div key={card.id} style={{ zIndex: idx }} className="relative transition-all duration-300">
             {isLandlord && idx === cards.length - 1 && isUser && (
                <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 text-2xl animate-bounce">ğŸ¤ </div>
             )}
            <Card 
                card={card} 
                selected={isUser && selectedCards.includes(card.id)}
                onClick={isUser ? onSelectCard : undefined}
                hidden={!isUser}
                isLord={isLandlord && !isUser} // åˆ«äººçš„ç‰ŒèƒŒé¢ä¹Ÿå¯ä»¥æ ‡è®°? ä¸, æ­£é¢æ ‡è®°
            />
        </div>
      ))}
    </div>
  );
};

// è®°ç‰Œå™¨ç»„ä»¶
const CardRecorder = ({ remainingCards }) => {
    const ranks = ['3','4','5','6','7','8','9','10','J','Q','K','A','2', 'Joker'];
    
    // è®¡ç®—æ¯ä¸ªç‚¹æ•°å‰©ä½™å¼ æ•°
    const getCount = (label) => {
        if (label === 'Joker') {
            return remainingCards.filter(c => c.rank >= 20).length;
        }
        return remainingCards.filter(c => c.display === label).length;
    };

    return (
        <div className="bg-black/60 text-white p-2 rounded-lg text-xs backdrop-blur-sm shadow-xl border border-white/20">
            <div className="font-bold mb-1 text-center text-yellow-400">è®°ç‰Œå™¨ (å‰©ä½™)</div>
            <div className="grid grid-cols-7 gap-x-2 gap-y-1">
                {ranks.map(r => {
                    const count = getCount(r);
                    let colorClass = 'text-white';
                    if (count === 4) colorClass = 'text-red-400 font-bold'; // ç‚¸å¼¹è­¦å‘Š
                    if (count === 0) colorClass = 'text-gray-500';
                    return (
                        <div key={r} className="flex justify-between w-full">
                           <span className="opacity-70">{r === 'Joker' ? 'ç‹' : r}</span>
                           <span className={colorClass}>{count}</span>
                        </div>
                    )
                })}
            </div>
        </div>
    );
};

// --- ä¸»ç¨‹åº ---

export default function DouDiZhu() {
  const [deck, setDeck] = useState([]);
  const [players, setPlayers] = useState([[], [], []]); 
  const [bottomCards, setBottomCards] = useState([]);
  const [landlord, setLandlord] = useState(null);
  const [turn, setTurn] = useState(null);
  const [phase, setPhase] = useState('MENU'); // MENU, BIDDING, PLAYING, GAME_OVER
  const [selectedCards, setSelectedCards] = useState([]);
  const [lastHand, setLastHand] = useState(null); 
  const [message, setMessage] = useState("æ¬¢è¿æ¥åˆ°æ–—åœ°ä¸»!");
  const [winner, setWinner] = useState(null);
  const [difficulty, setDifficulty] = useState('NORMAL');
  
  // è®°å½•æ¯ä¸ªç©å®¶æœ€åå‡ºçš„ç‰Œ
  const [tableCards, setTableCards] = useState({ 0: [], 1: [], 2: [] });
  // è®°å½•æ‰€æœ‰æœªçŸ¥çš„ç‰Œï¼ˆè®°ç‰Œå™¨ç”¨ï¼‰
  const [remainingCards, setRemainingCards] = useState([]); 
  const [bids, setBids] = useState({});

  // --- åˆå§‹åŒ–æ¸¸æˆ ---
  const initGame = () => {
      setPhase('MENU');
      setMessage("è¯·é€‰æ‹©æ¸¸æˆéš¾åº¦");
  };

  const startGame = () => {
    const newDeck = createDeck();
    // æ´—ç‰Œ
    for (let i = newDeck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
    }
    
    // å‘ç‰Œ
    const p1 = newDeck.slice(0, 17);
    const p2 = newDeck.slice(17, 34);
    const p3 = newDeck.slice(34, 51);
    const bottom = newDeck.slice(51);

    setDeck(newDeck);
    setPlayers([GameLogic.sortCards(p1), GameLogic.sortCards(p2), GameLogic.sortCards(p3)]);
    setBottomCards(bottom);
    setLandlord(null);
    setLastHand(null);
    setTableCards({ 0: [], 1: [], 2: [] });
    setWinner(null);
    setBids({});
    setSelectedCards([]);
    
    // è®°ç‰Œå™¨åˆå§‹çŠ¶æ€ï¼šé™¤äº†è‡ªå·±çš„ç‰Œï¼Œå…¶ä»–çš„éƒ½ç®—æœªçŸ¥
    setRemainingCards([...newDeck]);

    // å‰”é™¤ç©å®¶æ‰‹ç‰Œä¸­çš„ç‰Œ
    const myHandIds = p1.map(c => c.id);
    setRemainingCards(prev => prev.filter(c => !myHandIds.includes(c.id)));

    // éšæœºå†³å®šè°å…ˆå«åœ°ä¸»
    const firstBidder = Math.floor(Math.random() * 3);
    setTurn(firstBidder);
    setPhase('BIDDING');
    setMessage(`å¼€å§‹å«åœ°ä¸»ï¼Œç©å®¶ ${firstBidder === 0 ? 'ä½ ' : (firstBidder === 1 ? 'å³ä¾§ç”µè„‘' : 'å·¦ä¾§ç”µè„‘')} å…ˆå«ã€‚`);
  };

  // --- å«åœ°ä¸»é€»è¾‘ ---
  const handleBid = (score) => {
      const newBids = { ...bids, [turn]: score };
      setBids(newBids);

      if (score > 0) {
          // æˆä¸ºåœ°ä¸»
          setLandlord(turn);
          const newPlayers = [...players];
          newPlayers[turn] = GameLogic.sortCards([...newPlayers[turn], ...bottomCards]);
          setPlayers(newPlayers);
          
          // å¦‚æœåˆ«äººæ˜¯åœ°ä¸»ï¼Œåº•ç‰Œç¿»å¼€ï¼Œä»è®°ç‰Œå™¨ç§»é™¤
          const bottomIds = bottomCards.map(c => c.id);
          setRemainingCards(prev => prev.filter(c => !bottomIds.includes(c.id)));

          setPhase('PLAYING');
          setMessage(`${turn === 0 ? 'ä½ ' : 'ç”µè„‘'} æŠ¢åˆ°äº†åœ°ä¸»!`);
          setTableCards({ 0: [], 1: [], 2: [] }); 
      } else {
          // ä¸å«
          const nextTurn = (turn + 1) % 3;
          if (Object.keys(newBids).length === 3) {
             // å¼ºåˆ¶åœ°ä¸»
             setLandlord(nextTurn); 
             const newPlayers = [...players];
             newPlayers[nextTurn] = GameLogic.sortCards([...newPlayers[nextTurn], ...bottomCards]);
             setPlayers(newPlayers);
             
             const bottomIds = bottomCards.map(c => c.id);
             setRemainingCards(prev => prev.filter(c => !bottomIds.includes(c.id)));

             setPhase('PLAYING');
             setMessage(`æ²¡äººå«åœ°ä¸»ï¼Œ${nextTurn === 0 ? 'ä½ ' : 'ç”µè„‘'} è¢«è¿«è¥ä¸šã€‚`);
          } else {
             setTurn(nextTurn);
             setMessage(`ç©å®¶ ${turn} ä¸å«ï¼Œè½®åˆ°ç©å®¶ ${nextTurn}ã€‚`);
          }
      }
  };

  // --- AI è¡Œä¸ºå¾ªç¯ ---
  useEffect(() => {
    if (phase !== 'BIDDING' && phase !== 'PLAYING') return;

    let timer;
    if (turn !== 0) {
       timer = setTimeout(() => {
           if (phase === 'BIDDING') {
               const hand = players[turn];
               const goodCards = hand.filter(c => c.rank >= 15).length;
               // éš¾åº¦å½±å“å«ç‰Œæ¿€è¿›ç¨‹åº¦
               let threshold = 0.6;
               if (difficulty === 'HARD') threshold = 0.4;
               
               const shouldBid = goodCards >= 2 || Math.random() > threshold;
               handleBid(shouldBid ? 3 : 0);
           } else if (phase === 'PLAYING') {
               handleAIPlay();
           }
       }, 1500); // ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œç•™ç»™åŠ¨ç”»æ—¶é—´
    }
    return () => clearTimeout(timer);
  }, [turn, phase, players, lastHand, difficulty]);

  // --- AI å‡ºç‰Œé€»è¾‘ ---
  const handleAIPlay = () => {
     const aiHand = players[turn];
     const currentTarget = (lastHand && lastHand.playerId !== turn) ? lastHand.handAnalysis : null;
     
     const cardsToPlay = GameLogic.findBestMove(aiHand, currentTarget, difficulty);

     if (cardsToPlay) {
         playCards(turn, cardsToPlay);
     } else {
         passTurn(turn);
     }
  };

  // --- ç©å®¶/AI åŠ¨ä½œ ---
  
  const playCards = (playerId, cards) => {
      const currentAnalysis = GameLogic.analyzeHand(cards);
      
      // æ›´æ–°æ‰‹ç‰Œ
      const newPlayers = [...players];
      newPlayers[playerId] = newPlayers[playerId].filter(c => !cards.find(pc => pc.id === c.id));
      setPlayers(newPlayers);

      // è®°ç‰Œå™¨æ›´æ–°ï¼šç§»é™¤æ‰“å‡ºçš„ç‰Œ
      const playedIds = cards.map(c => c.id);
      setRemainingCards(prev => prev.filter(c => !playedIds.includes(c.id)));

      // æ›´æ–°åœºä¸Šæœ€åå‡ºçš„ç‰Œ
      const newHandInfo = { playerId, cards, handAnalysis: currentAnalysis };
      setLastHand(newHandInfo);
      
      const newTable = { ...tableCards };
      newTable[playerId] = cards; 
      // æ¸…ç©ºå…¶ä»–äººçš„å‡ºç‰Œæ˜¾ç¤ºï¼Œä¿è¯è§†è§‰ç„¦ç‚¹
      for(let i=0; i<3; i++) {
          if (i !== playerId) newTable[i] = []; 
      }

      setTableCards(newTable);

      const role = playerId === landlord ? 'åœ°ä¸»' : 'å†œæ°‘';
      const name = playerId === 0 ? 'ä½ ' : `ç”µè„‘${playerId === 1 ? '(å³)' : '(å·¦)'}`;
      setMessage(`${role} ${name} å‡ºäº† ${cards.length} å¼ ç‰Œ`);

      if (newPlayers[playerId].length === 0) {
          setPhase('GAME_OVER');
          const isLandlordWin = playerId === landlord;
          setWinner(isLandlordWin ? 'åœ°ä¸»' : 'å†œæ°‘');
          return;
      }

      setTurn((playerId + 1) % 3);
      if (playerId === 0) setSelectedCards([]);
  };

  const passTurn = (playerId) => {
      const newTable = { ...tableCards };
      newTable[playerId] = 'PASS'; 
      setTableCards(newTable);
      
      const nextPlayer = (playerId + 1) % 3;
      setTurn(nextPlayer);
  };

  const handleUserPlay = () => {
    const cards = players[0].filter(c => selectedCards.includes(c.id));
    const analysis = GameLogic.analyzeHand(cards);
    if (analysis.type === TYPES.INVALID) {
        alert("ç‰Œå‹ä¸åˆæ³•ï¼");
        return;
    }
    const target = (lastHand && lastHand.playerId !== 0) ? lastHand.handAnalysis : null;
    if (target && !GameLogic.canBeat(cards, target)) {
        alert("æ‰“ä¸è¿‡ä¸Šå®¶ï¼");
        return;
    }
    playCards(0, cards);
  };

  const handleUserPass = () => {
     if (!lastHand || lastHand.playerId === 0) {
         alert("ä½ æ˜¯å…ˆæ‰‹ï¼Œå¿…é¡»å‡ºç‰Œï¼");
         return;
     }
     passTurn(0);
     setSelectedCards([]);
  };

  const handleUserSelect = (card) => {
    if (phase !== 'PLAYING' || turn !== 0) return;
    setSelectedCards(prev => prev.includes(card.id) ? prev.filter(id => id !== card.id) : [...prev, card.id]);
  };

  // --- æ¸²æŸ“è¾…åŠ© ---
  const renderTableCards = (playerId) => {
    const content = tableCards[playerId];
    if (!content || content.length === 0) return null;
    
    if (content === 'PASS') {
        return <div className="text-white/80 font-bold text-2xl bg-black/40 px-6 py-2 rounded-full animate-pulse backdrop-blur-sm">ä¸è¦</div>;
    }
    
    const animationClass = "animate-zoom-in";
    const spacing = content.length > 5 ? '-space-x-8' : '-space-x-6';

    return (
        <div className={`flex ${spacing} origin-center transition-all duration-300 ${animationClass}`}>
            {content.map((c, i) => (
                <div key={i} style={{zIndex: i}} className="transform hover:-translate-y-2 transition-transform">
                    <Card card={c} small={false} /> 
                </div>
            ))}
        </div>
    );
  };

  // èœå•ç•Œé¢
  if (phase === 'MENU') {
      return (
        <div className="flex flex-col h-screen w-full bg-green-800 text-white items-center justify-center space-y-8 bg-pattern">
            <h1 className="text-6xl font-bold text-yellow-400 drop-shadow-lg mb-8">æ–—åœ°ä¸»</h1>
            <div className="flex gap-6">
                {Object.keys(DIFFICULTIES).map(key => (
                    <button 
                        key={key}
                        onClick={() => { setDifficulty(key); startGame(); }}
                        className={`${DIFFICULTIES[key].color} hover:brightness-110 text-white text-2xl font-bold py-4 px-10 rounded-2xl shadow-xl transition-transform hover:scale-105 active:scale-95`}
                    >
                        {DIFFICULTIES[key].label}æ¨¡å¼
                    </button>
                ))}
            </div>
            <div className="text-white/60 mt-8">é€‰æ‹©éš¾åº¦å¼€å§‹æ¸¸æˆ</div>
        </div>
      );
  }

  return (
    <div className="flex flex-col h-screen w-full bg-[#1a5c37] text-white overflow-hidden select-none font-sans relative">
      <style>{`
        .bg-pattern {
            background-image: radial-gradient(#2d8a55 15%, transparent 16%), radial-gradient(#2d8a55 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        @keyframes zoom-in {
            0% { transform: scale(0.5); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1.0); opacity: 1; }
        }
        .animate-zoom-in {
            animation: zoom-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
      `}</style>

      {/* é¡¶éƒ¨æ  */}
      <div className="flex justify-between items-center p-4 bg-black/20 shadow-lg h-16 z-20 backdrop-blur-sm">
        <div className="flex items-center gap-4">
             <button onClick={initGame} className="bg-white/20 hover:bg-white/30 px-3 py-1 rounded text-sm">è¿”å›</button>
             <div className="font-bold text-lg text-yellow-400">éš¾åº¦: {DIFFICULTIES[difficulty].label}</div>
             <div className="text-sm opacity-90 hidden md:block">{message}</div>
        </div>
        
        {/* åº•ç‰Œå±•ç¤º */}
        <div className="flex gap-2">
            {bottomCards.length > 0 ? bottomCards.map(c => (
                <div key={c.id} className="transform scale-75 origin-top">
                    <Card card={c} small hidden={phase === 'BIDDING'} />
                </div>
            )) : <div className="text-xs border border-white/30 p-2 rounded">åº•ç‰ŒåŒº</div>}
        </div>
      </div>

      {/* æ¸¸æˆä¸»åŒºåŸŸ */}
      <div className="flex-1 relative flex flex-col w-full max-w-7xl mx-auto">
        
        {/* å·¦ä¾§ç”µè„‘ (Player 2) */}
        <div className="absolute left-2 top-20 flex flex-col items-center gap-2 z-10">
             <div className={`flex flex-col items-center p-2 rounded-lg ${turn === 2 ? 'bg-yellow-500/20 ring-2 ring-yellow-400' : ''}`}>
                <div className={`w-16 h-16 rounded-full flex items-center justify-center text-3xl border-4 shadow-lg bg-gray-200 ${landlord === 2 ? 'border-yellow-500' : 'border-gray-500'}`}>
                    {landlord === 2 ? 'ğŸ¤ ' : 'ğŸ‘¨â€ğŸŒ¾'}
                </div>
                <div className="text-xs mt-1 font-bold bg-black/40 px-2 rounded-full">{players[2].length}å¼ </div>
             </div>
        </div>

        {/* å³ä¾§ç”µè„‘ (Player 1) */}
        <div className="absolute right-2 top-20 flex flex-col items-center gap-2 z-10">
             <div className={`flex flex-col items-center p-2 rounded-lg ${turn === 1 ? 'bg-yellow-500/20 ring-2 ring-yellow-400' : ''}`}>
                <div className={`w-16 h-16 rounded-full flex items-center justify-center text-3xl border-4 shadow-lg bg-gray-200 ${landlord === 1 ? 'border-yellow-500' : 'border-gray-500'}`}>
                    {landlord === 1 ? 'ğŸ¤ ' : 'ğŸ‘¨â€ğŸŒ¾'}
                </div>
                <div className="text-xs mt-1 font-bold bg-black/40 px-2 rounded-full">{players[1].length}å¼ </div>
             </div>
        </div>

        {/* è®°ç‰Œå™¨ (å³ä¸Šè§’ï¼Œä½†åœ¨å¤´åƒä¸‹æ–¹) */}
        <div className="absolute right-2 top-48 z-10 hidden md:block">
            <CardRecorder remainingCards={remainingCards} />
        </div>
        {/* ç§»åŠ¨ç«¯è®°ç‰Œå™¨ä½ç½® */}
        <div className="absolute top-16 left-1/2 transform -translate-x-1/2 z-0 opacity-80 md:hidden scale-75 origin-top">
             <CardRecorder remainingCards={remainingCards} />
        </div>


        {/* --- æ ¸å¿ƒå‡ºç‰Œå±•ç¤ºåŒº (å±å¹•ä¸­é—´) --- */}
        <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-0">
             <div className="absolute left-[15%] top-[35%] md:left-[20%]">
                 {renderTableCards(2)}
             </div>

             <div className="absolute right-[15%] top-[35%] md:right-[20%]">
                 {renderTableCards(1)}
             </div>

             <div className="absolute bottom-[40%] left-1/2 transform -translate-x-1/2">
                 {renderTableCards(0)}
             </div>
        </div>

        {/* èƒœåˆ©ç»“ç®— */}
        {winner && (
             <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                <div className="bg-white text-black p-8 rounded-2xl shadow-2xl text-center transform scale-110">
                    <div className="text-6xl mb-4">{winner === 'åœ°ä¸»' ? 'ğŸ¤ ' : 'ğŸ‘¨â€ğŸŒ¾'}</div>
                    <h1 className={`text-5xl font-bold mb-4 ${winner === 'åœ°ä¸»' ? 'text-yellow-600' : 'text-green-600'}`}>{winner} è·èƒœ!</h1>
                    <div className="flex justify-center gap-4 mt-6">
                        <button onClick={startGame} className="bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold px-8 py-3 rounded-full shadow-lg transition-transform hover:scale-105">
                            å†æ¥ä¸€å±€
                        </button>
                        <button onClick={initGame} className="bg-gray-200 hover:bg-gray-300 text-gray-800 text-xl font-bold px-8 py-3 rounded-full shadow-lg">
                            è¿”å›ä¸»é¡µ
                        </button>
                    </div>
                </div>
            </div>
        )}

        {/* åº•éƒ¨ç©å®¶æ§åˆ¶åŒº */}
        <div className="mt-auto mb-2 flex flex-col items-center gap-2 w-full z-30">
            
            {/* æç¤ºä¿¡æ¯ */}
            <div className="h-8 text-yellow-300 font-bold text-shadow">{turn === 0 ? "è½®åˆ°ä½ äº†!" : ""}</div>

            {/* æ§åˆ¶æŒ‰é’®ç»„ */}
            <div className="h-12 flex gap-4 items-center">
                {phase === 'BIDDING' && turn === 0 && (
                    <>
                        <button onClick={() => handleBid(3)} className="bg-yellow-500 hover:bg-yellow-600 text-white px-8 py-2 rounded-full font-bold shadow-lg transform transition active:scale-95 border-b-4 border-yellow-700">
                            å«åœ°ä¸»
                        </button>
                        <button onClick={() => handleBid(0)} className="bg-gray-500 hover:bg-gray-600 text-white px-8 py-2 rounded-full font-bold shadow-lg transform transition active:scale-95 border-b-4 border-gray-700">
                            ä¸å«
                        </button>
                    </>
                )}

                {phase === 'PLAYING' && turn === 0 && (
                    <>
                        {(!lastHand || lastHand.playerId !== 0) && (
                            <button onClick={handleUserPass} className="bg-orange-500 hover:bg-orange-600 text-white px-6 py-2 rounded-full font-bold shadow-lg border-b-4 border-orange-700 active:scale-95">
                                ä¸å‡º
                            </button>
                        )}
                        <button 
                            onClick={handleUserPlay} 
                            disabled={selectedCards.length === 0}
                            className={`px-10 py-2 rounded-full font-bold shadow-lg border-b-4 active:scale-95 transition-all
                                ${selectedCards.length > 0 
                                    ? 'bg-blue-500 hover:bg-blue-600 text-white border-blue-700' 
                                    : 'bg-gray-400 text-gray-200 border-gray-500 cursor-not-allowed'}`}
                        >
                            å‡ºç‰Œ
                        </button>
                        <button onClick={() => setSelectedCards([])} className="bg-white/20 hover:bg-white/30 text-white px-4 py-2 rounded-full text-sm backdrop-blur-md">
                            é‡é€‰
                        </button>
                    </>
                )}
            </div>

            {/* ç©å®¶æ‰‹ç‰Œ */}
            <div className="w-full px-2 overflow-visible pb-2 pt-4">
                <div className="flex items-center gap-2 mb-[-10px] ml-4">
                     <div className={`w-10 h-10 rounded-full flex items-center justify-center text-xl border-2 bg-gray-100 ${landlord === 0 ? 'border-yellow-500' : 'border-gray-500'}`}>
                        {landlord === 0 ? 'ğŸ¤ ' : 'ğŸ‘¨â€ğŸŒ¾'}
                    </div>
                    <span className="text-xs bg-black/50 px-2 py-1 rounded text-white">ä½ </span>
                </div>
                <Hand 
                    cards={players[0]} 
                    isUser={true} 
                    onSelectCard={handleUserSelect} 
                    selectedCards={selectedCards}
                    isLandlord={landlord === 0}
                />
            </div>
        </div>
      </div>
    </div>
  );
}